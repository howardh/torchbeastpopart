from collections import defaultdict
import logging

import numpy as np
from orion.algo.pbt.exploit import TruncateExploit
from orion.core.worker.trial import Trial
from orion.algo.pbt.pbt import LineageNode

logger = logging.getLogger(__name__)


class MultitaskTruncateExploit(TruncateExploit):
    def _truncate(
        self,
        rng,
        trial,
        trials,
    ):
        completed_trials = [trial for trial in trials if trial.status == "completed"]

        if len(completed_trials) < self.min_forking_population:
            logger.debug(
                "Not enough trials completed to exploit: %s", len(completed_trials)
            )
            return None

        if trial not in completed_trials:
            raise ValueError(
                f"Trial {trial.id} not included in list of completed trials."
            )

        # --- Sorting start ---

        returns_by_task = defaultdict(lambda: [])
        for trial in completed_trials:
            for r in trial.statistics:
                returns_by_task[r.name].append(r.value)

        task_stats = {
            task_id: {
                "mean": np.mean(returns), # type: ignore
                "std": np.std(returns), # type: ignore
            }
            for task_id, returns in returns_by_task.items()
        }

        normalized_returns = [{
            r.name: (r.value - task_stats[r.name]["mean"]) / task_stats[r.name]["std"]
            for r in trial.statistics
        } for trial in completed_trials]

        mean_normalized_returns = [
            np.mean([v for v in r.values()]) # type: ignore
            for r in normalized_returns
        ]

        sorted_trials = sorted(
            zip(completed_trials, mean_normalized_returns), key=lambda x: x[1]
        )
        sorted_trials = [t[0] for t in sorted_trials]

        #sorted_trials = sorted(
        #    completed_trials, key=lambda trial: trial.objective.value
        #)

        # --- Sorting end ---

        worse_trials = sorted_trials[
            int(self.truncation_quantile * len(sorted_trials)) :
        ]

        if trial not in worse_trials:
            logger.debug("Trial %s is good enough, no need to exploit.", trial)
            return trial

        candidate_threshold_index = int(self.candidate_pool_ratio * len(sorted_trials))

        if candidate_threshold_index == 0:
            logger.warning(
                "Not enough completed trials to have a candidate pool. "
                "You should consider increasing min_forking_population or candidate_pool_ratio"
            )
            return None

        index = rng.choice(np.arange(0, candidate_threshold_index))
        return sorted_trials[index]


class MultitaskBacktrackExploit(MultitaskTruncateExploit):
    def _get_elites(self, lineages, max_depth=None):
        """Get best trials of each lineage

        Each lineage is a path from a leaf to the root. When there is a forking,
        the path followed is not from child (new trial) to parent (forked trial), but
        rather to base trial (trial dropped). This is to represent the path taken
        by the sequence of trial execution within a worker. This also avoids having
        duplicate elite trials on different lineages.

        Best trials may be looked for up to a ``max_depth``.

        Parameters
        ----------
        max_depth: int or ``orion.core.worker.trial.Trial``, optional
            The maximum depth to look for best trials. It can be an int to represent the depth
            directly, or a trial, from which the depth will be infered. If a trial, this trial
            should be in the Lineages. Default: None, that is, no max depth.
        """
        if max_depth and not isinstance(max_depth, int):
            max_depth = lineages.get_lineage(max_depth).node_depth

        def get_parent_at_depth(node, depth):
            while node.node_depth > depth:
                node = node.parent

            return node

        trials = []
        for lineage in lineages._lineage_roots: # _lineage_roots is a list of LineageNode
            nodes = lineage.leafs # nodes is a list of LineageNode

            if max_depth is not None:
                trimmed_nodes = set()
                for node in nodes:
                    node = get_parent_at_depth(node, max_depth)
                    trimmed_nodes.add(node)
                nodes = list(trimmed_nodes)

            for node in nodes:
                if node.jumps and (
                    (max_depth is None) or (node.node_depth < max_depth)
                ):
                    continue

                best_trial = self._get_best_trial(node) # <--- This line was changed ---
                if best_trial is not None:
                    trials.append(best_trial)

        return trials

    def _get_best_trial(self, node: LineageNode):
        """Return best trial on the path from root up to this node.

        The path followed is through `true` ancestors, that is, looking at
        base if the current node is the result of a fork, otherwise looking at the parent.

        Only leaf node trials may not be completed. If there is only one node in the tree
        and the node's trial is not completed, ``None`` is returned instead of a trial object.

        Returns
        -------
        ``None``
            Only one node in the tree and it is not completed.

        ``orion.core.worker.trial.Trial``
            Trial with best objective (lowest).

        """
        parent_node = node.get_true_ancestor()

        if parent_node:
            parent_trial = parent_node.get_best_trial()

            #if get_objective(parent_trial) <= get_objective(node.item):
            if self._compare(parent_trial, node.item): # <--- This line was changed ---
                return parent_trial

        if node.item.status != "completed":
            return None

        return node.item
    
    def _compare(self, trial1: Trial, trial2: Trial):
        task_ids = [r.name for r in trial1.statistics]
        for r in trial2.statistics:
            assert r.name in task_ids
        trial1_stats = [trial1.statistics[task_id] for task_id in task_ids]
        trial2_stats = [trial2.statistics[task_id] for task_id in task_ids]
        diff_sign = np.sign(np.array(trial1_stats) - np.array(trial2_stats)) # type: ignore
        return diff_sign.sum() < 0
        #return get_objective(trial1) <= get_objective(trial2)

    def __call__(self, rng, trial, lineages):
        """Select other trial if current one not good enough
        If the given trial is under a ``self.truncation_quantile`` compared to all other best
        trials with lower or equal fidelity level,
        then a new candidate trial is selected for forking.
        The new candidate is selected from a pool of best ``self.candidate_pool_ratio``\\% of the
        best trials with lower or equal fidelity level. See class description for more
        explanation on the rationale.
        If there are less than ``self.min_forking_population`` trials that have reached the fidelity
        level as the passed trial, then `None` is return to signal that we should reconsider this
        trial later on when more trials are completed at this fidelity level.
        Parameters
        ----------
        rng: numpy.random.Generator
            A random number generator. It is not contained in ``BaseExploit`` because the exploit
            class must be stateless.
        trial: Trial
            The :py:class:`orion.core.worker.trial.Trial` that is currently under examination.
        lineages: Lineages
            All :py:class:`orion.algo.pbt.pbt.Lineages` created by the population based training
            algorithm that is using this exploit class.
        Returns
        -------
        ``None``
            The exploit class signals that there are not enough completed trials in lineages to make
            a decision for current trial.
        ``Trial``
            If the returned trial is the same as the one received as argument, it means that
            population based training should continue with same parameters.
            If another trial from the lineages is returned, it means that population based training
            should try to explore new parameters.
        """

        elites = lineages.get_elites(max_depth=trial) # See https://orion.readthedocs.io/en/stable/_modules/orion/algo/pbt/pbt.html#Lineages.get_elites
        return self._truncate(rng, trial, elites + [trial])
